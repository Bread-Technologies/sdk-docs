---
title: "Type Definitions"
description: "SDK type definitions and data models"
---

## Overview

The Bread SDK uses Pydantic models for responses and TypedDicts for request parameters (Python), or TypeScript interfaces and types (TypeScript), providing full type safety.

## Response Types

### RepoResponse

<CodeGroup>

```python Python
class RepoResponse:
    repo_name: str   # Repository name
    base_model: str  # Base model identifier
```

```typescript TypeScript
interface RepoResponse {
  repo_name: string;  // Repository name
  base_model: string; // Base model identifier
}
```

</CodeGroup>

### PromptResponse

<CodeGroup>

```python Python
class PromptResponse:
    prompt_name: str                                    # Prompt identifier
    messages: List[Message]                            # List of messages
    tools: Optional[List[Dict[str, object]]] = None    # List of available tools/functions (OpenAI format)
```

```typescript TypeScript
interface PromptResponse {
  prompt_name: string;                              // Prompt identifier
  messages: Message[];                              // List of messages
  tools?: Array<{ [key: string]: unknown }> | null; // List of available tools/functions (OpenAI format)
}
```

</CodeGroup>

### Message

<CodeGroup>

```python Python
class Message:
    role: str                                          # "system", "user", or "assistant"
    content: Union[str, List[Dict[str, object]], None] # Message content (can be null for assistant with tool_calls)
```

```typescript TypeScript
interface Message {
  role: string;                                        // "system", "user", or "assistant"
  content?: string | Array<{ [key: string]: unknown }> | null; // Message content (can be null for assistant with tool_calls)
  [k: string]: unknown;                                // Additional properties allowed
}
```

</CodeGroup>

### TargetResponse

<CodeGroup>

```python Python
class TargetResponse:
    target_name: str              # Target name
    config: Config                # Target configuration

class Config:
    generators: Optional[List[Generator]]
    model_name: Optional[str]
    teacher_prompt: Optional[str]    # Teacher prompt name (unconditioned stimulus)
    student_prompt: Optional[str]     # Student prompt name (conditioned stimulus)
    max_concurrency: Optional[int]
    max_tokens: Optional[int]
    num_traj_per_stimulus: Optional[int]
    temperature: Optional[float]
    extra_kwargs: Optional[Dict[str, Any]]
```

```typescript TypeScript
interface TargetResponse {
  target_name: string;        // Target name
  config: TargetResponse.Config; // Target configuration
}

namespace TargetResponse {
  export interface Config {
    generators?: Array<Generator> | null;
    model_name?: string | null;
    teacher_prompt?: string | null;  // Teacher prompt name (unconditioned stimulus)
    student_prompt?: string | null;  // Student prompt name (conditioned stimulus)
    max_concurrency?: number | null;
    max_tokens?: number | null;
    num_traj_per_stimulus?: number | null;
    temperature?: number | null;
    extra_kwargs?: { [key: string]: unknown } | null;
  }
}
```

</CodeGroup>

### BakeResponse

<CodeGroup>

```python Python
class BakeResponse:
    status: str                              # Job status: "not_started", "running", "complete", "failed"
    config: Optional[Dict[str, object]]     # Job config parameters
    error: Optional[str]                    # Error message if job failed
    job_id: Optional[int]                   # Coordinator job ID (if job is queued/running)
    lines: Optional[int]                    # Number of output lines (not applicable for bakes)
    progress_percent: Optional[float]        # Job progress percentage (0-100) if job is running
    loss: Optional[Dict[str, float]]         # Loss values from training (latest_loss, final_loss, min_loss, max_loss)
    model_name: Optional[List[str]]          # List of model names in format 'user/repo/bake_name/checkpoint' (only when status is 'complete')
```

```typescript TypeScript
interface BakeResponse {
  status: string;                                    // Job status: "not_started", "running", "complete", "failed"
  config?: { [key: string]: unknown } | null;       // Job config parameters
  error?: string | null;                            // Error message if job failed
  job_id?: number | null;                            // Coordinator job ID (if job is queued/running)
  lines?: number | null;                             // Number of output lines (not applicable for bakes)
  progress_percent?: number | null;                  // Job progress percentage (0-100) if job is running
  loss?: { [key: string]: number } | null;           // Loss values from training (latest_loss, final_loss, min_loss, max_loss)
  model_name?: Array<string> | null;                 // List of model names in format 'user/repo/bake_name/checkpoint' (only when status is 'complete')
}
```

</CodeGroup>

### HealthCheckResponse

<CodeGroup>

```python Python
class HealthCheckResponse:
    status: str   # "healthy" or "degraded"
    api: str      # API name
    version: str  # API version
```

```typescript TypeScript
interface HealthCheckResponse {
  status: string;  // "healthy" or "degraded"
  api: string;     // API name
  version: string; // API version
}
```

</CodeGroup>

### BakeDownloadResponse

<CodeGroup>

```python Python
class BakeDownloadResponse:
    bake_name: str   # Bake name
    checkpoint: int  # Checkpoint number
    expires_in: int  # URL expiry time in seconds
    url: str         # Presigned URL for downloading weights
```

```typescript TypeScript
interface BakeDownloadResponse {
  bake_name: string;   // Bake name
  checkpoint: number;  // Checkpoint number
  expires_in: number;  // URL expiry time in seconds
  url: string;         // Presigned URL for downloading weights
}
```

</CodeGroup>

### BakeGetMetricsResponse

<CodeGroup>

```python Python
# List of metrics entries
BakeGetMetricsResponse = List[Dict[str, Any]]
```

```typescript TypeScript
type BakeGetMetricsResponse = Array<{ [key: string]: unknown }>;
```

</CodeGroup>

### RepoGetTreeResponse

<CodeGroup>

```python Python
class RepoGetTreeResponse:
    bakes: Dict[str, BakeTreeNode]  # Dictionary of all bakes in the repository
    base_model: str                 # Base model name (e.g., 'Qwen/Qwen3-32B')
    edges: List[List[str]]          # List of parent-child edges: [source_type, source_name, target_type, target_name]

class BakeTreeNode:
    config: Dict[str, object]       # Bake configuration (bake.yml)
    status: str                    # Bake status: complete, failed, running, pending, unknown
    checkpoints: Optional[List[int]] # List of checkpoint numbers
    model_name: Optional[List[str]]  # List of full model paths with checkpoints
```

```typescript TypeScript
interface RepoGetTreeResponse {
  bakes: Record<string, BakeTreeNode>; // Dictionary of all bakes in the repository
  base_model: string;                  // Base model name (e.g., 'Qwen/Qwen3-32B')
  edges: string[][];                   // List of parent-child edges: [source_type, source_name, target_type, target_name]
}

interface BakeTreeNode {
  config: Record<string, unknown>;     // Bake configuration (bake.yml)
  status: string;                      // Bake status: complete, failed, running, pending, unknown
  checkpoints?: number[] | null;       // List of checkpoint numbers
  model_name?: string[] | null;        // List of full model paths with checkpoints
}
```

</CodeGroup>

### RecipeGetDependencyGraphResponse

<CodeGroup>

```python Python
class RecipeGetDependencyGraphResponse:
    bakes: Dict[str, Dict[str, object]]    # Dictionary of bake configs (collation + bake)
    base_model: str                        # Base model name
    edges: List[List[object]]              # List of dependency edges (source_type, source_name, target_type, target_name)
    prompts: Dict[str, Optional[str]]      # Dictionary of prompt names to file paths
    targets: Dict[str, Dict[str, object]]  # Dictionary of target configs (stim + rollout)
```

```typescript TypeScript
interface RecipeGetDependencyGraphResponse {
  bakes: Record<string, Record<string, unknown>>;    // Dictionary of bake configs (collation + bake)
  base_model: string;                                // Base model name
  edges: unknown[][];                                // List of dependency edges
  prompts: Record<string, string | null>;            // Dictionary of prompt names to file paths
  targets: Record<string, Record<string, unknown>>;  // Dictionary of target configs (stim + rollout)
}
```

</CodeGroup>

### RecipeGetRecreationPlanResponse

<CodeGroup>

```python Python
class RecipeGetRecreationPlanResponse:
    base_model: str        # Base model name (e.g., 'Qwen/Qwen3-32B')
    resources: Resources   # Summary of all resources
    steps: List[Step]      # Ordered list of steps to recreate the bake
    total_steps: int       # Total number of steps

class Resources:
    bakes: List[ResourcesBake] # List of bake resources with model names
    prompts: List[str]         # List of prompt names
    targets: List[str]         # List of target names

class ResourcesBake:
    bake_name: str
    model_names: Optional[List[str]]

class Step:
    action: str            # Action to perform: create_prompt, create_target, run_stim, run_rollout, create_bake, run_bake
    config: Dict[str, Any] # Configuration for this resource (cleaned, no internal paths)
    dependencies: List[str] # List of dependencies in format 'resource_type:resource_name'
    resource_name: str
    resource_type: str
    step: int              # Step number in execution order
```

```typescript TypeScript
interface RecipeGetRecreationPlanResponse {
  base_model: string;     // Base model name (e.g., 'Qwen/Qwen3-32B')
  resources: Resources;   // Summary of all resources
  steps: Step[];         // Ordered list of steps to recreate the bake
  total_steps: number;    // Total number of steps
}

interface Resources {
  bakes: ResourcesBake[]; // List of bake resources with model names
  prompts: string[];      // List of prompt names
  targets: string[];      // List of target names
}

interface ResourcesBake {
  bake_name: string;
  model_names?: string[] | null;
}

interface Step {
  action: string;         // Action to perform: create_prompt, create_target, run_stim, run_rollout, create_bake, run_bake
  config: Record<string, unknown>; // Configuration for this resource (cleaned, no internal paths)
  dependencies: string[]; // List of dependencies in format 'resource_type:resource_name'
  resource_name: string;
  resource_type: string;
  step: number;           // Step number in execution order
}
```

</CodeGroup>

## Request Parameter Types

### MessageParam

<CodeGroup>

```python Python
from aibread.types import MessageParam

class MessageParam(TypedDict, total=False):
    role: str                                          # Required: "system", "user", "assistant"
    content: Optional[Union[str, List[Dict[str, object]]]]  # Message content (can be null for assistant with tool_calls)

# Usage
messages: List[MessageParam] = [
    {"role": "system", "content": "You are helpful"},
    {"role": "user", "content": "Hello"}
]
```

```typescript TypeScript
interface MessageParam {
  role: string;                                        // Required: "system", "user", "assistant"
  content?: string | Array<{ [key: string]: unknown }> | null; // Message content (can be null for assistant with tool_calls)
  [k: string]: unknown;                                // Additional properties allowed
}

// Usage
const messages: MessageParam[] = [
  { role: 'system', content: 'You are helpful' },
  { role: 'user', content: 'Hello' },
];
```

</CodeGroup>

### TargetConfigBaseParam

<CodeGroup>

```python Python
from aibread.types import TargetConfigBaseParam

class TargetConfigBaseParam(TypedDict, total=False):
    generators: Optional[Iterable[GeneratorParam]]
    model_name: Optional[str]
    teacher_prompt: Optional[str]    # Teacher prompt name (unconditioned stimulus)
    student_prompt: Optional[str]     # Student prompt name (conditioned stimulus)
    u: Optional[str]                 # [DEPRECATED] Use 'teacher_prompt' instead
    v: Optional[str]                 # [DEPRECATED] Use 'student_prompt' instead
    max_concurrency: Optional[int]
    max_tokens: Optional[int]
    num_traj_per_stimulus: Optional[int]
    temperature: Optional[float]
    extra_kwargs: Optional[Dict[str, Any]]
```

```typescript TypeScript
interface TargetConfigBase {
  generators?: Array<Generator> | null;
  model_name?: string | null;
  teacher_prompt?: string | null;  // Teacher prompt name (unconditioned stimulus)
  student_prompt?: string | null;  // Student prompt name (conditioned stimulus)
  u?: string | null;               // [DEPRECATED] Use 'teacher_prompt' instead
  v?: string | null;               // [DEPRECATED] Use 'student_prompt' instead
  max_concurrency?: number | null;
  max_tokens?: number | null;
  num_traj_per_stimulus?: number | null;
  temperature?: number | null;
  extra_kwargs?: { [key: string]: unknown } | null;
}
```

</CodeGroup>

### BakeConfigBaseParam

<CodeGroup>

```python Python
from aibread.types import BakeConfigBaseParam

class BakeConfigBaseParam(TypedDict, total=False):
    datasets: Optional[Iterable[DatasetItemParam]]
    epochs: Optional[int]
    micro_batch_size: Optional[int]
    gradient_accumulation_steps: Optional[int]
    total_trajectories: Optional[int]
    seed: Optional[int]
    model: Optional[ModelConfigParam]
    optimizer: Optional[OptimizerConfigParam]
    scheduler: Optional[SchedulerConfigParam]
    deepspeed: Optional[DeepspeedConfigParam]
    checkpoint: Optional[Iterable[CheckpointConfigParam]]
    data: Optional[DataConfigParam]
    eval_interval: Optional[int]
    train_log_iter_interval: Optional[int]
    type: Optional[str]
    model_name: Optional[str]
```

```typescript TypeScript
interface BakeConfigBase {
  datasets?: Array<DatasetItem> | null;
  epochs?: number | null;
  micro_batch_size?: number | null;
  gradient_accumulation_steps?: number | null;
  total_trajectories?: number | null;
  seed?: number | null;
  model?: ModelConfig | null;
  optimizer?: OptimizerConfig | null;
  scheduler?: SchedulerConfig | null;
  deepspeed?: DeepspeedConfig | null;
  checkpoint?: Array<CheckpointConfig> | null;
  data?: DataConfig | null;
  eval_interval?: number | null;
  train_log_iter_interval?: number | null;
  type?: string | null;
  model_name?: string | null;
}
```

</CodeGroup>

## Working with Types

### Type Imports

<CodeGroup>

```python Python
from aibread import Bread
from aibread.types import (
    RepoResponse,
    PromptResponse,
    TargetResponse,
    BakeResponse,
    Message,
    MessageParam,
    HealthCheckResponse
)
```

```typescript TypeScript
import Bread from '@aibread/sdk';
import type {
  RepoResponse,
  PromptResponse,
  TargetResponse,
  BakeResponse,
  Message,
  MessageParam,
  HealthCheckResponse,
} from '@aibread/sdk';
```

</CodeGroup>

### Type Hints

<CodeGroup>

```python Python
from aibread import Bread
from aibread.types import RepoResponse, PromptResponse
from typing import List

def get_repository(name: str) -> RepoResponse:
    client = Bread()
    return client.repo.get(name)

def create_prompt(
    name: str,
    repo: str,
    messages: List[MessageParam]
) -> PromptResponse:
    client = Bread()
    return client.prompts.set(
        prompt_name=name,
        repo_name=repo,
        messages=messages
    )
```

```typescript TypeScript
import Bread, { PromptResponse, MessageParam } from '@aibread/sdk';

async function getRepository(name: string): Promise<RepoResponse> {
  const client = new Bread();
  return await client.repo.get(name);
}

async function createPrompt(
  name: string,
  repo: string,
  messages: MessageParam[]
): Promise<PromptResponse> {
  const client = new Bread();
  return await client.prompts.create(repo, {
    prompt_name: name,
    messages,
  });
}
```

</CodeGroup>

### Response Serialization

<CodeGroup>

```python Python
repo = client.repo.get("my_repo")

# To JSON
json_str = repo.to_json()           # Pretty-printed
compact = repo.to_json(indent=None)  # Compact

# To dictionary
data = repo.to_dict()
data_all = repo.to_dict(exclude_unset=False)
```

```typescript TypeScript
const repo = await client.repo.get('my_repo');

// To JSON
const jsonStr = JSON.stringify(repo, null, 2);  // Pretty-printed
const compact = JSON.stringify(repo);  // Compact

// To plain object (already a plain object in TypeScript)
const data = { ...repo };
```

</CodeGroup>

### Check Fields Set

<CodeGroup>

```python Python
repo = client.repo.get("my_repo")

if 'base_model' not in repo.model_fields_set:
    print('Field was not in API response')
```

```typescript TypeScript
const repo = await client.repo.get('my_repo');

// Check if field exists
if (!('base_model' in repo)) {
  console.log('Field was not in API response');
}

// Type-safe check
if (repo.base_model === undefined) {
  console.log('Field was not in API response');
}
```

</CodeGroup>

### Access Extra Fields

<CodeGroup>

```python Python
response = client.repo.get("my_repo")

# Access unknown property
extra = response.unknown_prop

# Get all extra fields
all_extras = response.model_extra
```

```typescript TypeScript
const response = await client.repo.get('my_repo');

// Access unknown property (TypeScript may require type assertion)
const extra = (response as any).unknownProp;

// Get all extra fields if SDK exposes them
const allExtras = (response as any).extraFields || {};
```

</CodeGroup>

## Generator Types

<CodeGroup>

```python Python
# Oneshot QS
{
    "type": "oneshot_qs",
    "model": str,
    "numq": int,
    "temperature": float,
    "max_tokens": int | None,
    "rollout_with_conditioned": bool | None,
    "template_path": str | None,
    "template_content": str | None
}

# Hardcoded
{
    "type": "hardcoded",
    "numq": int,
    "questions": List[str],
    "max_tokens": int | None,
    "rollout_with_conditioned": bool | None
}

# From Dataset
{
    "type": "from_dataset",
    "dataset": str,
    "numq": int,
    "seed": int,
    "max_tokens": int | None,
    "rollout_with_conditioned": bool | None
}

# Persona
{
    "type": "persona",
    "numq": int,
    "seed": int,
    "temperature": float,
    "max_tokens": int | None,
    "rollout_with_conditioned": bool | None
}

```

```typescript TypeScript
// Oneshot QS
interface OneshotGenerator {
  type: 'oneshot_qs';
  model: string;
  numq: number;
  temperature: number;
  max_tokens?: number | null;
  rollout_with_conditioned?: boolean | null;
  template_path?: string | null;
  template_content?: string | null;
}

// Hardcoded
interface HardcodedGenerator {
  type: 'hardcoded';
  numq: number;
  questions: string[];
  max_tokens?: number | null;
  rollout_with_conditioned?: boolean | null;
}

// From Dataset
interface FromDatasetGenerator {
  type: 'from_dataset';
  dataset: string;
  numq: number;
  seed: number;
  max_tokens?: number | null;
  rollout_with_conditioned?: boolean | null;
}

// Persona
interface PersonaGenerator {
  type: 'persona';
  numq: number;
  seed: number;
  temperature: number;
  max_tokens?: number | null;
  rollout_with_conditioned?: boolean | null;
}

// Union type for all generators
type Generator = 
  | OneshotGenerator 
  | HardcodedGenerator 
  | FromDatasetGenerator 
  | PersonaGenerator;
```

</CodeGroup>

## Type Safety Example

<CodeGroup>

```python Python
from typing import List
from aibread import Bread
from aibread.types import MessageParam, PromptResponse

def create_coding_prompts(repo_name: str) -> List[PromptResponse]:
    """Type-safe prompt creation"""
    client = Bread()
    
    prompts: List[MessageParam] = [
        {"role": "system", "content": "You are a coder"},
        {"role": "user", "content": "Task: {task}"}
    ]
    
    response: PromptResponse = client.prompts.set(
        prompt_name="coding_prompt",
        repo_name=repo_name,
        messages=prompts
    )
    
    return [response]
```

```typescript TypeScript
import Bread, { MessageParam, PromptResponse } from '@aibread/sdk';

async function createCodingPrompts(
  repoName: string
): Promise<PromptResponse[]> {
  /** Type-safe prompt creation */
  const client = new Bread();
  
  const prompts: MessageParam[] = [
    { role: 'system', content: 'You are a coder' },
    { role: 'user', content: 'Task: {task}' },
  ];
  
  const response: PromptResponse = await client.prompts.create(repoName, {
    prompt_name: 'coding_prompt',
    messages: prompts,
  });
  
  return [response];
}
```

</CodeGroup>

## Configuration Sub-types

These types are used within `BakeConfigBaseParam` and `TargetConfigBaseParam`.

### ModelConfig

<CodeGroup>

```python Python
class ModelConfigParam(TypedDict, total=False):
    type: Optional[str]
    parent_model_name: Optional[str]
    baked_adapter_config: Optional[BakedAdapterConfig]
    dtype: Optional[str]
    attn_implementation: Optional[str]
    disable_activation_checkpoint: Optional[bool]
    peft_config: Optional[Dict[str, object]]

class BakedAdapterConfig(TypedDict, total=False):
    r: Optional[int]
    lora_alpha: Optional[int]
    lora_dropout: Optional[float]
    bias: Optional[str]
    target_modules: Optional[str]
```

```typescript TypeScript
interface ModelConfig {
  type?: string | null;
  parent_model_name?: string | null;
  baked_adapter_config?: BakedAdapterConfig | null;
  dtype?: string | null;
  attn_implementation?: string | null;
  disable_activation_checkpoint?: boolean | null;
  peft_config?: Record<string, unknown> | null;
}

interface BakedAdapterConfig {
  r?: number | null;
  lora_alpha?: number | null;
  lora_dropout?: number | null;
  bias?: string | null;
  target_modules?: string | null;
}
```

</CodeGroup>

### DataConfig

<CodeGroup>

```python Python
class DataConfigParam(TypedDict, total=False):
    type: Optional[str]
    sources: Optional[Iterable[DataSourceParam]]
    eval_sources: Optional[Iterable[DataSourceParam]]
    max_length: Optional[int]
    train_eval_split: Optional[Iterable[float]]
    dl_num_workers: Optional[int]
    num_proc: Optional[int]
    seed: Optional[int]
    beta: Optional[float]
    temperature: Optional[float]

class DataSourceParam(TypedDict, total=False):
    type: Optional[str]
    name_or_path: Optional[str]
    split: Optional[str]
    max_samples: Optional[int]
    process: Optional[bool]
```

```typescript TypeScript
interface DataConfig {
  type?: string | null;
  sources?: DataSource[] | null;
  eval_sources?: DataSource[] | null;
  max_length?: number | null;
  train_eval_split?: number[] | null;
  dl_num_workers?: number | null;
  num_proc?: number | null;
  seed?: number | null;
  beta?: number | null;
  temperature?: number | null;
}

interface DataSource {
  type?: string | null;
  name_or_path?: string | null;
  split?: string | null;
  max_samples?: number | null;
  process?: boolean | null;
}
```

</CodeGroup>

### Optimizer & Scheduler

<CodeGroup>

```python Python
class OptimizerConfigParam(TypedDict, total=False):
    type: Optional[str]
    learning_rate: Optional[float]
    weight_decay: Optional[float]
    betas: Optional[Iterable[float]]

class SchedulerConfigParam(TypedDict, total=False):
    type: Optional[str]

class DatasetItemParam(TypedDict, total=False):
    target: Required[str]
    weight: Optional[float]
```

```typescript TypeScript
interface OptimizerConfig {
  type?: string | null;
  learning_rate?: number | null;
  weight_decay?: number | null;
  betas?: number[] | null;
}

interface SchedulerConfig {
  type?: string | null;
}

interface DatasetItem {
  target: string;
  weight?: number;
}
```

</CodeGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Use Type Hints" icon="code">
    Add type hints to your functions for better IDE support and type checking
  </Accordion>

  <Accordion title="Import Types Explicitly" icon="file-import">
    Import types from `aibread.types` for better autocomplete
  </Accordion>

  <Accordion title="Validate TypedDicts" icon="check-double">
    Use TypedDicts for request parameters to catch errors at development time
  </Accordion>

  <Accordion title="Check Model Fields" icon="magnifying-glass">
    Use `model_fields_set` to check which fields were actually returned by the API
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="API Reference"
    icon="code"
    href="/api-reference/repo"
  >
    Explore API methods
  </Card>
  <Card
    title="Production Patterns"
    icon="shield"
    href="/sdk/guides/production-patterns"
  >
    Learn common patterns
  </Card>
</CardGroup>

