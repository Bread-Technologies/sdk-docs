---
title: "Model Lineage & Recipes"
description: "Understand bake dependencies and recreate models using recipe endpoints"
---

Recipe endpoints help you understand model lineage, visualize dependencies between bakes, and recreate complex model hierarchies. This guide shows how to use recipe functionality with the SDK.

<Note>
**SDK Support**: 
- **TypeScript SDK**: `getDependencyGraph()` and `getRecreationPlan()` are available via `client.recipes`. `getTree()` is available via `client.repo.getTree()`.
- **Python SDK**: `get_dependency_graph()` and `get_recreation_plan()` are available via `client.recipes`. The tree endpoint is not yet available - use the REST API directly.
</Note>

## Understanding Model Lineage

When bakes depend on other bakes (using checkpoints), they form a lineage tree. Recipe endpoints help you:

- **Visualize dependencies**: See how bakes, targets, and prompts connect
- **Recreate models**: Get step-by-step plans to rebuild complex model hierarchies
- **Track evolution**: View the complete model lineage tree for a repository

---

## Get Dependency Graph

The dependency graph shows all resources needed to recreate a specific bake, including parent bakes and all transitive dependencies.

<CodeGroup>

```typescript TypeScript
import Bread from '@aibread/sdk';

const client = new Bread({
  apiKey: process.env.BREAD_API_KEY,
});

// Get dependency graph for a bake
const graph = await client.recipes.getDependencyGraph('my_bake', {
  repo_name: 'my_repo',
});

console.log(`Base model: ${graph.base_model}`);
console.log(`\nBakes:`);
for (const [name, config] of Object.entries(graph.bakes)) {
  console.log(`  ${name}:`, config);
}

console.log(`\nTargets:`);
for (const [name, config] of Object.entries(graph.targets)) {
  console.log(`  ${name}:`, config);
}

console.log(`\nPrompts:`);
for (const [name, path] of Object.entries(graph.prompts)) {
  console.log(`  ${name}: ${path}`);
}

console.log(`\nDependency edges:`);
for (const edge of graph.edges) {
  const [sourceType, sourceName, targetType, targetName] = edge;
  console.log(`  ${sourceType}:${sourceName} -> ${targetType}:${targetName}`);
}
```

```python Python
import os
from aibread import Bread

client = Bread(api_key=os.environ.get('BREAD_API_KEY'))

# Get dependency graph for a bake
graph = client.recipes.get_dependency_graph(
    'my_bake',
    repo_name='my_repo'
)

print(f"Base model: {graph.base_model}")
print("\nBakes:")
for name, config in graph.bakes.items():
    print(f"  {name}: {config}")

print("\nTargets:")
for name, config in graph.targets.items():
    print(f"  {name}: {config}")

print("\nPrompts:")
for name, path in graph.prompts.items():
    print(f"  {name}: {path}")

print("\nDependency edges:")
for edge in graph.edges:
    source_type, source_name, target_type, target_name = edge
    print(f"  {source_type}:{source_name} -> {target_type}:{target_name}")
```

</CodeGroup>

**Use Cases**:
- Understanding what resources a bake depends on
- Debugging missing dependencies
- Documenting model architecture
- Planning migrations or recreations

---

## Get Recreation Plan

The recreation plan provides a step-by-step, topologically sorted list of actions needed to recreate a bake and all its dependencies.

<CodeGroup>

```typescript TypeScript
import Bread from '@aibread/sdk';

const client = new Bread({
  apiKey: process.env.BREAD_API_KEY,
});

// Get recreation plan
const plan = await client.recipes.getRecreationPlan('my_bake', {
  repo_name: 'my_repo',
});

console.log(`Base model: ${plan.base_model}`);
console.log(`Total steps: ${plan.total_steps}`);
console.log(`\nResources needed:`);
console.log(`  Prompts: ${plan.resources.prompts.join(', ')}`);
console.log(`  Targets: ${plan.resources.targets.join(', ')}`);
console.log(`  Bakes: ${plan.resources.bakes.join(', ')}`);

console.log(`\nExecution plan:`);
for (const step of plan.steps) {
  console.log(`\nStep ${step.step}: ${step.action}`);
  console.log(`  Resource: ${step.resource_type}:${step.resource_name}`);
  if (step.dependencies.length > 0) {
    console.log(`  Depends on: ${step.dependencies.join(', ')}`);
  }
  console.log(`  Config:`, JSON.stringify(step.config, null, 2));
}
```

```python Python
import os
import json
from aibread import Bread

client = Bread(api_key=os.environ.get('BREAD_API_KEY'))

# Get recreation plan
plan = client.recipes.get_recreation_plan(
    'my_bake',
    repo_name='my_repo'
)

print(f"Base model: {plan.base_model}")
print(f"Total steps: {plan.total_steps}")
print("\nResources needed:")
print(f"  Prompts: {', '.join(plan.resources.prompts)}")
print(f"  Targets: {', '.join(plan.resources.targets)}")
print(f"  Bakes: {', '.join(plan.resources.bakes)}")

print("\nExecution plan:")
for step in plan.steps:
    print(f"\nStep {step.step}: {step.action}")
    print(f"  Resource: {step.resource_type}:{step.resource_name}")
    if step.dependencies:
        print(f"  Depends on: {', '.join(step.dependencies)}")
    print(f"  Config: {json.dumps(step.config, indent=2)}")
```

</CodeGroup>

**Use Cases**:
- Recreating a bake in a new repository
- Understanding execution order for complex workflows
- Automating model recreation
- Documentation and training

---

## Get Repository Tree

The repository tree shows the complete model lineage for all bakes in a repository, including parent-child relationships and status.

<CodeGroup>

```typescript TypeScript
import Bread from '@aibread/sdk';

const client = new Bread({
  apiKey: process.env.BREAD_API_KEY,
});

// Get repository tree
const tree = await client.repo.getTree('my_repo');

// Visualize lineage
// tree.bakes is a dictionary keyed by bake name
// tree.edges contains parent-child relationships: [source_type, source_name, target_type, target_name]
function printBake(bakeName: string, bake: any, indent = 0) {
  const prefix = '  '.repeat(indent);
  const statusIcon = bake.status === 'complete' ? '✓' : bake.status === 'running' ? '⟳' : '○';
  console.log(`${prefix}${statusIcon} ${bakeName} (${bake.status})`);
  
  if (bake.model_name && bake.model_name.length > 0) {
    console.log(`${prefix}  Models: ${bake.model_name.join(', ')}`);
  }
  
  // Find children using edges
  const children = tree.edges
    .filter((edge: string[]) => edge[0] === 'bake' && edge[2] === 'bake' && edge[3] === bakeName)
    .map((edge: string[]) => edge[1]);
  
  if (children.length > 0) {
    console.log(`${prefix}  Children:`);
    for (const childName of children) {
      if (tree.bakes[childName]) {
        printBake(childName, tree.bakes[childName], indent + 2);
      }
    }
  }
}

// Find root bakes (no incoming edges)
const allBakes = new Set(Object.keys(tree.bakes));
const childBakes = new Set(
  tree.edges
    .filter((edge: string[]) => edge[0] === 'bake' && edge[2] === 'bake')
    .map((edge: string[]) => edge[1])
);
const rootBakes = Array.from(allBakes).filter(name => !childBakes.has(name));

console.log(`Base model: ${tree.base_model}`);
console.log('Model Lineage Tree:\n');
for (const bakeName of rootBakes) {
  printBake(bakeName, tree.bakes[bakeName]);
}
```

```python Python
# Note: The tree endpoint is not yet available in the Python SDK.
# Use the REST API directly or check for future SDK updates.

import os
import requests

response = requests.get(
    "https://bapi.bread.com.ai/v1/repo/my_repo/tree",
    headers={"Authorization": f"Bearer {os.environ.get('BREAD_API_KEY')}"}
)

tree = response.json()

# tree['bakes'] is a dictionary keyed by bake name
# tree['edges'] contains parent-child relationships: [source_type, source_name, target_type, target_name]
def print_bake(bake_name, bake, indent=0):
    prefix = '  ' * indent
    status_icon = '✓' if bake['status'] == 'complete' else '⟳' if bake['status'] == 'running' else '○'
    print(f"{prefix}{status_icon} {bake_name} ({bake['status']})")
    
    if bake['model_name']:
        print(f"{prefix}  Models: {', '.join(bake['model_name'])}")
    
    # Find children using edges
    children = [
        edge[1] for edge in tree['edges']
        if edge[0] == 'bake' and edge[2] == 'bake' and edge[3] == bake_name
    ]
    
    if children:
        print(f"{prefix}  Children:")
        for child_name in children:
            if child_name in tree['bakes']:
                print_bake(child_name, tree['bakes'][child_name], indent + 2)

# Find root bakes (no incoming edges)
all_bakes = set(tree['bakes'].keys())
child_bakes = set(
    edge[1] for edge in tree['edges']
    if edge[0] == 'bake' and edge[2] == 'bake'
)
root_bakes = all_bakes - child_bakes

print(f"Base model: {tree['base_model']}")
print('Model Lineage Tree:\n')
for bake_name in root_bakes:
    print_bake(bake_name, tree['bakes'][bake_name])
```

</CodeGroup>

**Use Cases**:
- Visualizing complete model evolution
- Finding all child models derived from a base bake
- Tracking model status across the repository
- Understanding model relationships without specifying a starting point

---

## Example: Recreating a Model

Here's a complete example of using the recreation plan to recreate a bake:

<CodeGroup>

```typescript TypeScript
import Bread from '@aibread/sdk';

const client = new Bread({
  apiKey: process.env.BREAD_API_KEY,
});

async function recreateBake(sourceRepo: string, targetRepo: string, bakeName: string) {
  // Get recreation plan
  const plan = await client.recipes.getRecreationPlan(bakeName, {
    repo_name: sourceRepo,
  });

  // Ensure target repo exists
  await client.repo.create({
    repo_name: targetRepo,
    base_model: plan.base_model,
  });

  // Execute steps in order
  for (const step of plan.steps) {
    console.log(`Executing step ${step.step}: ${step.action} ${step.resource_type}:${step.resource_name}`);
    
    switch (step.resource_type) {
      case 'prompt':
        await client.prompts.create(targetRepo, {
          prompt_name: step.resource_name,
          messages: step.config.messages as any,
        });
        break;
        
      case 'target':
        await client.targets.create(targetRepo, {
          target_name: step.resource_name,
          template: 'default',
          overrides: step.config as any,
        });
        break;
        
      case 'bake':
        await client.bakes.create(targetRepo, {
          bake_name: step.resource_name,
          template: 'default',
          overrides: step.config as any,
        });
        break;
    }
  }

  console.log(`\nRecreation complete! Bake '${bakeName}' is ready in repo '${targetRepo}'`);
}

// Usage
recreateBake('source_repo', 'target_repo', 'my_bake');
```

```python Python
import os
from aibread import Bread

client = Bread(api_key=os.environ.get('BREAD_API_KEY'))

def recreate_bake(source_repo: str, target_repo: str, bake_name: str):
    # Get recreation plan
    plan = client.recipes.get_recreation_plan(
        bake_name,
        repo_name=source_repo
    )
    
    # Ensure target repo exists
    client.repo.create(repo_name=target_repo, base_model=plan.base_model)
    
    # Execute steps in order
    for step in plan.steps:
        print(f"Executing step {step.step}: {step.action} {step.resource_type}:{step.resource_name}")
        
        if step.resource_type == 'prompt':
            client.prompts.create(
                repo_name=target_repo,
                prompt_name=step.resource_name,
                messages=step.config['messages']
            )
        elif step.resource_type == 'target':
            client.targets.create(
                repo_name=target_repo,
                target_name=step.resource_name,
                template='default',
                overrides=step.config
            )
        elif step.resource_type == 'bake':
            client.bakes.create(
                repo_name=target_repo,
                bake_name=step.resource_name,
                template='default',
                overrides=step.config
            )
    
    print(f"\nRecreation complete! Bake '{bake_name}' is ready in repo '{target_repo}'")

# Usage
recreate_bake('source_repo', 'target_repo', 'my_bake')
```

</CodeGroup>

---

## Related Documentation

- [API Reference: Recipes](/api-reference/recipes) - Complete REST API documentation
- [Using Baked Models](/sdk/guides/using-baked-models) - Load and use your baked models
- [Production Patterns](/sdk/guides/production-patterns) - Best practices for production workflows



