---
title: "Production Patterns"
description: "Battle-tested patterns for async workflows, error handling, and monitoring"
---

Production workflows need polling, error handling, retries, and monitoring. This guide shows battle-tested patterns for building robust baking pipelines.

<Note>
These patterns build on the [basic baking workflows](/sdk/guides/single-prompt-bake). Use them when deploying to production.
</Note>

## Overview

Production-ready baking workflows need:
- **Job polling** - Wait for async operations (stim, rollout, bake) to complete
- **Error handling** - Gracefully handle auth failures, timeouts, API errors
- **Retry logic** - Automatically retry transient failures
- **Logging** - Track progress for debugging and monitoring
- **Timeouts** - Prevent jobs from running indefinitely
- **Async support** - Better concurrency for high-throughput pipelines

---

## Job Polling Pattern

### The Problem

Stim, rollout, and bake jobs run asynchronously. You need to wait for completion:

```python
# This starts the job but doesn't wait
client.targets.stim.run(target_name="my_target", repo_name="my_repo")

# How do you know when it's done?
```

### The Solution

Poll for job status with proper intervals:

<CodeGroup>

```python Python
import time
from typing import Callable, Any

def wait_for_job(
    get_status_fn: Callable[[], Any],
    job_name: str,
    poll_interval: int = 5,
    timeout: int = 3600
) -> Any:
    """Poll job status until completion or timeout."""
    start_time = time.time()
    deadline = start_time + timeout
    
    while time.time() < deadline:
        try:
            status = get_status_fn()
            
            if status.status == "complete":
                return status
            
            if status.status == "failed":
                error_msg = getattr(status, "error", "Unknown error")
                raise RuntimeError(f"{job_name} failed: {error_msg}")
            
            time.sleep(poll_interval)
        except Exception as e:
            if "timeout" in str(e).lower() or "connection" in str(e).lower():
                raise
            # Retry on transient errors
            time.sleep(poll_interval)
    
    raise TimeoutError(f"{job_name} exceeded {timeout}s timeout")
```

```typescript TypeScript
async function waitForJob(
  getStatusFn: () => Promise<{ status: string; lines?: number; error?: string }>,
  jobName: string,
  pollInterval: number = 5,
  timeout: number = 3600
): Promise<{ status: string; lines?: number }> {
  /** Poll job status until completion or timeout. */
  const deadline = Date.now() + timeout * 1000;
  
  while (Date.now() < deadline) {
    try {
      const status = await getStatusFn();
      
      if (status.status === 'complete') {
        return status;
      }
      
      if (status.status === 'failed') {
        throw new Error(`${jobName} failed: ${status.error || 'Unknown error'}`);
      }
      
      await new Promise(resolve => setTimeout(resolve, pollInterval * 1000));
    } catch (error: any) {
      if (error.message?.includes('timeout') || error.message?.includes('connection')) {
        throw error;
      }
      // Retry on transient errors
      await new Promise(resolve => setTimeout(resolve, pollInterval * 1000));
    }
  }
  
  throw new Error(`${jobName} exceeded ${timeout}s timeout`);
}
```

</CodeGroup>

**Usage:**

<CodeGroup>

```python Python
from aibread import Bread

client = Bread()

# Start job and wait for completion
client.targets.stim.run(target_name="my_target", repo_name="my_repo")
status = wait_for_job(
    lambda: client.targets.stim.get("my_target", repo_name="my_repo"),
    job_name="Stim",
    poll_interval=5,
    timeout=3600
)
print(f"Generated {status.lines} lines")
```

```typescript TypeScript
import Bread from '@aibread/sdk';

const client = new Bread();

// Start job and wait for completion
await client.targets.stim.run('my_target', { repo_name: 'my_repo' });
const status = await waitForJob(
  () => client.targets.stim.get('my_target', { repo_name: 'my_repo' }),
  'Stim',
  5,
  3600
);
console.log(`Generated ${status.lines} lines`);
```

</CodeGroup>

### Recommended Poll Intervals

| Job Type | Interval | Typical Duration |
|----------|----------|------------------|
| Stim | 5 seconds | 30s - 5min |
| Rollout | 10 seconds | 2min - 30min |
| Bake | 30 seconds | 10min - 2hours |

---

## Error Handling Pattern

### Comprehensive Error Handling

Handle specific error types with appropriate responses:

<CodeGroup>

```python Python
import aibread
from aibread import Bread

def safe_bake_workflow(repo_name: str, target_name: str):
    """
    Production workflow with comprehensive error handling.
    """
    try:
        client = Bread()
        
        # Verify repository exists
        try:
            client.repo.get(repo_name)
        except aibread.NotFoundError:
            print(f"Repository '{repo_name}' not found, creating...")
            client.repo.set(repo_name=repo_name)
        
        # Run stim with error handling
        try:
            client.targets.stim.run(
                target_name=target_name,
                repo_name=repo_name
            )
            wait_for_job(
                lambda: client.targets.stim.get(target_name, repo_name=repo_name),
                "Stim",
                timeout=3600
            )
        except TimeoutError as e:
            print(f"Stim timed out: {e}")
            raise
        
        # Run rollout with error handling
        try:
            client.targets.rollout.run(
                target_name=target_name,
                repo_name=repo_name
            )
            wait_for_job(
                lambda: client.targets.rollout.get(target_name, repo_name=repo_name),
                "Rollout",
                timeout=7200
            )
        except TimeoutError as e:
            print(f"Rollout timed out: {e}")
            raise
        
        print("Workflow completed successfully")
        
    except aibread.AuthenticationError:
        print("Authentication failed - check BREAD_API_KEY")
        raise
    
    except aibread.APIConnectionError as e:
        print(f"Connection failed: {e}")
        print("Check your internet connection and API endpoint")
        raise
    
    except aibread.RateLimitError as e:
        print(f"Rate limited: {e}")
        print("Wait before retrying")
        raise
    
    except aibread.APIStatusError as e:
        print(f"API error {e.status_code}: {e.response}")
        raise
    
    except Exception as e:
        print(f"Unexpected error: {e}")
        raise


# Usage
safe_bake_workflow("my_repo", "my_target")
```

```typescript TypeScript
import Bread, { NotFoundError, AuthenticationError, APIConnectionError, RateLimitError, APIStatusError } from '@aibread/sdk';

async function safeBakeWorkflow(repoName: string, targetName: string): Promise<void> {
  /**
   * Production workflow with comprehensive error handling.
   */
  try {
    const client = new Bread();
    
    // Verify repository exists
    try {
      await client.repo.get(repoName);
    } catch (error) {
      if (error instanceof NotFoundError) {
        console.log(`Repository '${repoName}' not found, creating...`);
        await client.repo.create({ repo_name: repoName });
      } else {
        throw error;
      }
    }
    
    // Run stim with error handling
    try {
      await client.targets.stim.run(targetName, {
        repo_name: repoName,
      });
      await waitForJob(
        async () => await client.targets.stim.get(targetName, { repo_name: repoName }),
        'Stim',
        5,
        3600
      );
    } catch (error) {
      if (error instanceof Error && error.message.includes('timeout')) {
        console.log(`Stim timed out: ${error.message}`);
        throw error;
      }
      throw error;
    }
    
    // Run rollout with error handling
    try {
      await client.targets.rollout.run(targetName, {
        repo_name: repoName,
      });
      await waitForJob(
        async () => await client.targets.rollout.get(targetName, { repo_name: repoName }),
        'Rollout',
        10,
        7200
      );
    } catch (error) {
      if (error instanceof Error && error.message.includes('timeout')) {
        console.log(`Rollout timed out: ${error.message}`);
        throw error;
      }
      throw error;
    }
    
    console.log('Workflow completed successfully');
    
  } catch (error) {
    if (error instanceof AuthenticationError) {
      console.log('Authentication failed - check BREAD_API_KEY');
      throw error;
    }
    
    if (error instanceof APIConnectionError) {
      console.log(`Connection failed: ${error.message}`);
      console.log('Check your internet connection and API endpoint');
      throw error;
    }
    
    if (error instanceof RateLimitError) {
      console.log(`Rate limited: ${error.message}`);
      console.log('Wait before retrying');
      throw error;
    }
    
    if (error instanceof APIStatusError) {
      console.log(`API error ${error.statusCode}: ${error.response}`);
      throw error;
    }
    
    console.log(`Unexpected error: ${error}`);
    throw error;
  }
}


// Usage
await safeBakeWorkflow('my_repo', 'my_target');
```

</CodeGroup>

---

## Retry Pattern

### Automatic Retries for Transient Failures

Some failures are temporary (network blips, rate limits). Retry with exponential backoff:

<CodeGroup>

```python Python
import time
from functools import wraps
import aibread

def retry_on_failure(max_attempts=3, backoff_factor=2):
    """
    Decorator for automatic retries with exponential backoff.
    
    Args:
        max_attempts: Maximum retry attempts
        backoff_factor: Multiplier for wait time (2 = double each retry)
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                
                except aibread.APIConnectionError as e:
                    if attempt == max_attempts - 1:
                        raise
                    
                    wait_time = backoff_factor ** attempt
                    print(f"Connection error, retrying in {wait_time}s... (attempt {attempt + 1}/{max_attempts})")
                    time.sleep(wait_time)
                
                except aibread.RateLimitError as e:
                    if attempt == max_attempts - 1:
                        raise
                    
                    # Rate limit errors often include retry-after
                    wait_time = getattr(e, 'retry_after', backoff_factor ** attempt)
                    print(f"Rate limited, retrying in {wait_time}s...")
                    time.sleep(wait_time)
            
            return None
        return wrapper
    return decorator


# Usage
@retry_on_failure(max_attempts=3, backoff_factor=2)
def create_target(client, target_name, repo_name, config):
    """Create target with automatic retries."""
    return client.targets.set(
        target_name=target_name,
        repo_name=repo_name,
        template="default",
        overrides=config
    )


# Calls will automatically retry on connection/rate limit errors
create_target(client, "my_target", "my_repo", {...})
```

```typescript TypeScript
import { APIConnectionError, RateLimitError } from '@aibread/sdk';

function retryOnFailure<T extends (...args: any[]) => Promise<any>>(
  fn: T,
  maxAttempts: number = 3,
  backoffFactor: number = 2
): T {
  /** Wrapper for automatic retries with exponential backoff */
  return (async (...args: Parameters<T>) => {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        return await fn(...args);
      } catch (error) {
        if (error instanceof APIConnectionError) {
          if (attempt === maxAttempts - 1) {
            throw error;
          }
          const waitTime = Math.pow(backoffFactor, attempt);
          console.log(
            `Connection error, retrying in ${waitTime}s... (attempt ${attempt + 1}/${maxAttempts})`
          );
          await new Promise(resolve => setTimeout(resolve, waitTime * 1000));
        } else if (error instanceof RateLimitError) {
          if (attempt === maxAttempts - 1) {
            throw error;
          }
          // Rate limit errors often include retry-after
          const waitTime = (error as any).retryAfter || Math.pow(backoffFactor, attempt);
          console.log(`Rate limited, retrying in ${waitTime}s...`);
          await new Promise(resolve => setTimeout(resolve, waitTime * 1000));
        } else {
          throw error;
        }
      }
    }
    throw new Error('Max retries exceeded');
  }) as T;
}

// Usage
const createTarget = retryOnFailure(
  async (client: any, targetName: string, repoName: string, config: any) => {
    return await client.targets.create(repoName, {
      target_name: targetName,
      template: 'default',
      overrides: config,
    });
  },
  3,
  2
);

// Calls will automatically retry on connection/rate limit errors
await createTarget(client, 'my_target', 'my_repo', {});
```

</CodeGroup>

---

## Logging Pattern

### Structured Logging for Production

Use proper logging libraries for log levels and formatting:

<CodeGroup>

```python Python
import logging
from aibread import Bread

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def production_bake_workflow(
    repo_name: str,
    target_name: str,
    bake_name: str
):
    """Production workflow with comprehensive logging."""
    logger.info(f"Starting bake workflow: {bake_name}")
    
    try:
        client = Bread()
        logger.info("Client initialized")
        
        # Stim
        logger.info(f"Starting stim for target: {target_name}")
        client.targets.stim.run(target_name=target_name, repo_name=repo_name)
        
        status = wait_for_job(
            lambda: client.targets.stim.get(target_name, repo_name=repo_name),
            "Stim"
        )
        logger.info(f"Stim completed: {status.lines} lines generated")
        
        # Rollout
        logger.info(f"Starting rollout for target: {target_name}")
        client.targets.rollout.run(target_name=target_name, repo_name=repo_name)
        
        status = wait_for_job(
            lambda: client.targets.rollout.get(target_name, repo_name=repo_name),
            "Rollout"
        )
        logger.info(f"Rollout completed: {status.lines} trajectories")
        
        # Bake
        logger.info(f"Starting bake: {bake_name}")
        client.bakes.run(bake_name=bake_name, repo_name=repo_name)
        
        status = wait_for_job(
            lambda: client.bakes.get(bake_name, repo_name=repo_name),
            "Bake",
            poll_interval=30
        )
        logger.info(f"Bake completed successfully: {bake_name}")
        
        return status
        
    except Exception as e:
        logger.error(f"Workflow failed: {e}", exc_info=True)
        raise


# Usage
production_bake_workflow("my_repo", "my_target", "my_bake")
```

```typescript TypeScript
import Bread from '@aibread/sdk';

// Simple logger (use winston, pino, or similar in production)
const logger = {
  info: (msg: string) => console.log(`[INFO] ${new Date().toISOString()} - ${msg}`),
  error: (msg: string, error?: Error) => {
    console.error(`[ERROR] ${new Date().toISOString()} - ${msg}`);
    if (error) console.error(error);
  },
};

async function productionBakeWorkflow(
  repoName: string,
  targetName: string,
  bakeName: string
): Promise<any> {
  /** Production workflow with comprehensive logging */
  logger.info(`Starting bake workflow: ${bakeName}`);
  
  try {
    const client = new Bread();
    logger.info('Client initialized');
    
    // Stim
    logger.info(`Starting stim for target: ${targetName}`);
    await client.targets.stim.run(targetName, { repo_name: repoName });
    
    const stimStatus = await waitForJob(
      () => client.targets.stim.get(targetName, { repo_name: repoName }),
      'Stim',
      5,
      3600
    );
    logger.info(`Stim completed: ${stimStatus.lines} lines generated`);
    
    // Rollout
    logger.info(`Starting rollout for target: ${targetName}`);
    await client.targets.rollout.run(targetName, { repo_name: repoName });
    
    const rolloutStatus = await waitForJob(
      () => client.targets.rollout.get(targetName, { repo_name: repoName }),
      'Rollout',
      10,
      7200
    );
    logger.info(`Rollout completed: ${rolloutStatus.lines} trajectories`);
    
    // Bake
    logger.info(`Starting bake: ${bakeName}`);
    await client.bakes.run(bakeName, { repo_name: repoName });
    
    const bakeStatus = await waitForJob(
      () => client.bakes.get(bakeName, { repo_name: repoName }),
      'Bake',
      30,
      14400
    );
    logger.info(`Bake completed successfully: ${bakeName}`);
    
    return bakeStatus;
  } catch (error) {
    logger.error(`Workflow failed: ${error}`, error as Error);
    throw error;
  }
}

// Usage
await productionBakeWorkflow('my_repo', 'my_target', 'my_bake');
```

</CodeGroup>

---

## Async Pattern

### Async/Await for Better Concurrency

Use async workflows when running multiple bakes in parallel:

<CodeGroup>

```python Python
import asyncio
from aibread import AsyncBread

async def async_wait_for_job(
    client,
    get_status_coro,
    job_name: str,
    poll_interval: int = 5,
    timeout: int = 3600
):
    """Async version of wait_for_job."""
    print(f"Waiting for {job_name}...")
    start_time = asyncio.get_event_loop().time()
    deadline = start_time + timeout
    
    while asyncio.get_event_loop().time() < deadline:
        # Get status
        status = await get_status_coro()
        
        if status.status == "complete":
            print(f"{job_name} complete")
            return status
        
        if status.status == "failed":
            raise RuntimeError(f"{job_name} failed")
        
        await asyncio.sleep(poll_interval)
    
    raise TimeoutError(f"{job_name} exceeded timeout")


async def async_target_workflow(
    repo_name: str,
    target_name: str
):
    """Complete async target workflow."""
    async with AsyncBread() as client:
        # Run stim
        await client.targets.stim.run(target_name=target_name, repo_name=repo_name)
        await async_wait_for_job(
            client,
            lambda: client.targets.stim.get(target_name, repo_name=repo_name),
            "Stim"
        )
        
        # Run rollout
        await client.targets.rollout.run(target_name=target_name, repo_name=repo_name)
        await async_wait_for_job(
            client,
            lambda: client.targets.rollout.get(target_name, repo_name=repo_name),
            "Rollout",
            poll_interval=10
        )
        
        print(f"Workflow complete: {target_name}")


# Run multiple workflows in parallel
async def run_parallel_workflows():
    """Run multiple target workflows concurrently."""
    await asyncio.gather(
        async_target_workflow("repo1", "target1"),
        async_target_workflow("repo2", "target2"),
        async_target_workflow("repo3", "target3")
    )


# Usage
asyncio.run(run_parallel_workflows())
```

```typescript TypeScript
import Bread from '@aibread/sdk';

async function asyncWaitForJob(
  getStatusFn: () => Promise<any>,
  jobName: string,
  pollInterval: number = 5,
  timeout: number = 3600
): Promise<any> {
  /** Async version of waitForJob */
  console.log(`Waiting for ${jobName}...`);
  const deadline = Date.now() + timeout * 1000;
  
  while (Date.now() < deadline) {
    const status = await getStatusFn();
    
    if (status.status === 'complete') {
      console.log(`${jobName} complete`);
      return status;
    }
    
    if (status.status === 'failed') {
      throw new Error(`${jobName} failed`);
    }
    
    await new Promise(resolve => setTimeout(resolve, pollInterval * 1000));
  }
  
  throw new Error(`${jobName} exceeded timeout`);
}

async function asyncTargetWorkflow(
  repoName: string,
  targetName: string
): Promise<void> {
  /** Complete async target workflow */
  const client = new Bread();
  
  // Run stim
  await client.targets.stim.run(targetName, { repo_name: repoName });
  await asyncWaitForJob(
    () => client.targets.stim.get(targetName, { repo_name: repoName }),
    'Stim',
    5,
    3600
  );
  
  // Run rollout
  await client.targets.rollout.run(targetName, { repo_name: repoName });
  await asyncWaitForJob(
    () => client.targets.rollout.get(targetName, { repo_name: repoName }),
    'Rollout',
    10,
    7200
  );
  
  console.log(`Workflow complete: ${targetName}`);
}

// Run multiple workflows in parallel
async function runParallelWorkflows(): Promise<void> {
  /** Run multiple target workflows concurrently */
  await Promise.all([
    asyncTargetWorkflow('repo1', 'target1'),
    asyncTargetWorkflow('repo2', 'target2'),
    asyncTargetWorkflow('repo3', 'target3'),
  ]);
}

// Usage
await runParallelWorkflows();
```

</CodeGroup>

---

## Complete Production Example

Putting it all together:

<CodeGroup>

```python Python
import logging
import time
import aibread
from aibread import Bread
from typing import Callable

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def wait_for_job(
    get_status_fn: Callable,
    job_name: str,
    poll_interval: int = 5,
    timeout: int = 3600
):
    """Poll job until completion with timeout."""
    logger.info(f"Waiting for {job_name}...")
    start_time = time.time()
    deadline = start_time + timeout
    
    while time.time() < deadline:
        status = get_status_fn()
        
        if status.status == "complete":
            logger.info(f"{job_name} complete ({status.lines} lines)")
            return status
        
        if status.status == "failed":
            raise RuntimeError(f"{job_name} failed: {status.error}")
        
        logger.debug(f"{job_name}: {status.status}")
        time.sleep(poll_interval)
    
    raise TimeoutError(f"{job_name} exceeded {timeout}s timeout")


def retry_on_failure(max_attempts=3):
    """Decorator for automatic retries."""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except (aibread.APIConnectionError, aibread.RateLimitError) as e:
                    if attempt == max_attempts - 1:
                        raise
                    wait_time = 2 ** attempt
                    logger.warning(f"Retry {attempt + 1}/{max_attempts} after {wait_time}s")
                    time.sleep(wait_time)
        return wrapper
    return decorator


@retry_on_failure(max_attempts=3)
def create_target_with_retry(client, target_name, repo_name, config):
    """Create target with automatic retries."""
    return client.targets.set(
        target_name=target_name,
        repo_name=repo_name,
        template="default",
        overrides=config
    )


def production_workflow(
    repo_name: str,
    target_name: str,
    target_config: dict,
    bake_name: str,
    bake_config: dict
):
    """
    Complete production workflow with error handling, retries, and logging.
    """
    logger.info(f"Starting production workflow: {bake_name}")
    
    try:
        client = Bread()
        
        # Create/verify repository
        try:
            client.repo.get(repo_name)
            logger.info(f"Repository '{repo_name}' exists")
        except aibread.NotFoundError:
            logger.info(f"Creating repository: {repo_name}")
            client.repo.set(repo_name=repo_name)
        
        # Create target with retry
        logger.info(f"Creating target: {target_name}")
        create_target_with_retry(client, target_name, repo_name, target_config)
        
        # Run stim
        logger.info("Starting stim job")
        client.targets.stim.run(target_name=target_name, repo_name=repo_name)
        wait_for_job(
            lambda: client.targets.stim.get(target_name, repo_name=repo_name),
            "Stim",
            poll_interval=5,
            timeout=3600
        )
        
        # Run rollout
        logger.info("Starting rollout job")
        client.targets.rollout.run(target_name=target_name, repo_name=repo_name)
        wait_for_job(
            lambda: client.targets.rollout.get(target_name, repo_name=repo_name),
            "Rollout",
            poll_interval=10,
            timeout=7200
        )
        
        # Configure and run bake
        logger.info(f"Configuring bake: {bake_name}")
        client.bakes.set(
            bake_name=bake_name,
            repo_name=repo_name,
            template="default",
            overrides=bake_config
        )
        
        logger.info("Starting bake")
        client.bakes.run(bake_name=bake_name, repo_name=repo_name)
        wait_for_job(
            lambda: client.bakes.get(bake_name, repo_name=repo_name),
            "Bake",
            poll_interval=30,
            timeout=14400  # 4 hours
        )
        
        logger.info(f"Production workflow completed: {bake_name}")
        return True
        
    except aibread.AuthenticationError:
        logger.error("Authentication failed - check BREAD_API_KEY")
        raise
    
    except aibread.APIConnectionError as e:
        logger.error(f"Connection failed: {e}")
        raise
    
    except TimeoutError as e:
        logger.error(f"Job timeout: {e}")
        raise
    
    except Exception as e:
        logger.error(f"Workflow failed: {e}", exc_info=True)
        raise


# Usage
production_workflow(
    repo_name="production_repo",
    target_name="yoda_target",
    target_config={
        "generators": [...],
        "model_name": "Qwen/Qwen3-32B",
        "teacher_prompt": "yoda_teacher",
        "student_prompt": "empty_student"
    },
    bake_name="yoda_production_v1",
    bake_config={
        "datasets": [{"target": "yoda_target", "weight": 1.0}],
        "epochs": 3
    }
)
```

```typescript TypeScript
import Bread, {
  NotFoundError,
  AuthenticationError,
  APIConnectionError,
  RateLimitError,
} from '@aibread/sdk';

// Simple logger (use winston, pino, or similar in production)
const logger = {
  info: (msg: string) => console.log(`[INFO] ${new Date().toISOString()} - ${msg}`),
  warning: (msg: string) => console.warn(`[WARN] ${new Date().toISOString()} - ${msg}`),
  error: (msg: string, error?: Error) => {
    console.error(`[ERROR] ${new Date().toISOString()} - ${msg}`);
    if (error) console.error(error);
  },
  debug: (msg: string) => console.debug(`[DEBUG] ${new Date().toISOString()} - ${msg}`),
};

async function waitForJob(
  getStatusFn: () => Promise<any>,
  jobName: string,
  pollInterval: number = 5,
  timeout: number = 3600
): Promise<any> {
  /** Poll job until completion with timeout */
  logger.info(`Waiting for ${jobName}...`);
  const deadline = Date.now() + timeout * 1000;
  
  while (Date.now() < deadline) {
    const status = await getStatusFn();
    
    if (status.status === 'complete') {
      logger.info(`${jobName} complete (${status.lines} lines)`);
      return status;
    }
    
    if (status.status === 'failed') {
      throw new Error(`${jobName} failed: ${status.error}`);
    }
    
    logger.debug(`${jobName}: ${status.status}`);
    await new Promise(resolve => setTimeout(resolve, pollInterval * 1000));
  }
  
  throw new Error(`${jobName} exceeded ${timeout}s timeout`);
}

async function retryOnFailure<T>(
  fn: () => Promise<T>,
  maxAttempts: number = 3
): Promise<T> {
  /** Wrapper for automatic retries */
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (error instanceof APIConnectionError || error instanceof RateLimitError) {
        if (attempt === maxAttempts - 1) {
          throw error;
        }
        const waitTime = Math.pow(2, attempt);
        logger.warning(`Retry ${attempt + 1}/${maxAttempts} after ${waitTime}s`);
        await new Promise(resolve => setTimeout(resolve, waitTime * 1000));
      } else {
        throw error;
      }
    }
  }
  throw new Error('Max retries exceeded');
}

async function createTargetWithRetry(
  client: Bread,
  targetName: string,
  repoName: string,
  config: any
): Promise<any> {
  /** Create target with automatic retries */
  return await retryOnFailure(() =>
    client.targets.create(repoName, {
      target_name: targetName,
      template: 'default',
      overrides: config,
    })
  );
}

async function productionWorkflow(
  repoName: string,
  targetName: string,
  targetConfig: any,
  bakeName: string,
  bakeConfig: any
): Promise<boolean> {
  /**
   * Complete production workflow with error handling, retries, and logging.
   */
  logger.info(`Starting production workflow: ${bakeName}`);
  
  try {
    const client = new Bread();
    
    // Create/verify repository
    try {
      await client.repo.get(repoName);
      logger.info(`Repository '${repoName}' exists`);
    } catch (error) {
      if (error instanceof NotFoundError) {
        logger.info(`Creating repository: ${repoName}`);
        await client.repo.create({ repo_name: repoName });
      } else {
        throw error;
      }
    }
    
    // Create target with retry
    logger.info(`Creating target: ${targetName}`);
    await createTargetWithRetry(client, targetName, repoName, targetConfig);
    
    // Run stim
    logger.info('Starting stim job');
    await client.targets.stim.run(targetName, { repo_name: repoName });
    await waitForJob(
      () => client.targets.stim.get(targetName, { repo_name: repoName }),
      'Stim',
      5,
      3600
    );
    
    // Run rollout
    logger.info('Starting rollout job');
    await client.targets.rollout.run(targetName, { repo_name: repoName });
    await waitForJob(
      () => client.targets.rollout.get(targetName, { repo_name: repoName }),
      'Rollout',
      10,
      7200
    );
    
    // Configure and run bake
    logger.info(`Configuring bake: ${bakeName}`);
    await client.bakes.create(repoName, {
      bake_name: bakeName,
      template: 'default',
      overrides: bakeConfig,
    });
    
    logger.info('Starting bake');
    await client.bakes.run(bakeName, { repo_name: repoName });
    await waitForJob(
      () => client.bakes.get(bakeName, { repo_name: repoName }),
      'Bake',
      30,
      14400  // 4 hours
    );
    
    logger.info(`Production workflow completed: ${bakeName}`);
    return true;
  } catch (error) {
    if (error instanceof AuthenticationError) {
      logger.error('Authentication failed - check BREAD_API_KEY', error);
      throw error;
    }
    
    if (error instanceof APIConnectionError) {
      logger.error(`Connection failed: ${error.message}`, error);
      throw error;
    }
    
    if (error instanceof Error && error.message.includes('timeout')) {
      logger.error(`Job timeout: ${error.message}`, error);
      throw error;
    }
    
    logger.error(`Workflow failed: ${error}`, error as Error);
    throw error;
  }
}

// Usage
await productionWorkflow(
  'production_repo',
  'yoda_target',
  {
    generators: [],
    model_name: 'Qwen/Qwen3-32B',
    teacher_prompt: 'yoda_teacher',
    student_prompt: 'empty_student',
  },
  'yoda_production_v1',
  {
    datasets: [{ target: 'yoda_target', weight: 1.0 }],
    epochs: 3,
  }
);
```

</CodeGroup>

---

## Best Practices

<AccordionGroup>
  <Accordion title="Use Appropriate Timeouts" icon="clock">
    Set realistic timeouts based on job type. Stim: 1h, Rollout: 2h, Bake: 4h.
  </Accordion>

  <Accordion title="Log Everything" icon="file-lines">
    Log start/completion of each phase, error details, and timing info for debugging.
  </Accordion>

  <Accordion title="Retry Transient Failures" icon="rotate">
    Automatically retry connection errors and rate limits with exponential backoff.
  </Accordion>

  <Accordion title="Handle All Error Types" icon="shield">
    Catch specific exceptions (AuthenticationError, APIConnectionError) not just Exception.
  </Accordion>

  <Accordion title="Use Async for Parallel Jobs" icon="bolt">
    Process multiple targets concurrently with asyncio for better throughput.
  </Accordion>

  <Accordion title="Monitor with Weights & Biases" icon="chart-line">
    Integrate [W&B](/sdk/configuration/bake-config#wandb-integration) for training metrics.
  </Accordion>
</AccordionGroup>

---

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Error Handling Guide"
    icon="triangle-exclamation"
    href="/sdk/guides/error-handling"
  >
    Deep dive on SDK error types
  </Card>
  <Card
    title="Bake Configuration"
    icon="gear"
    href="/sdk/configuration/bake-config"
  >
    Configure Weights & Biases integration
  </Card>
  <Card
    title="Single-Prompt Bake"
    icon="fire"
    href="/sdk/guides/single-prompt-bake"
  >
    Review basic baking workflow
  </Card>
  <Card
    title="Multi-Target Baking"
    icon="layer-group"
    href="/sdk/guides/multi-target-baking"
  >
    Apply patterns to multi-target workflows
  </Card>
</CardGroup>

