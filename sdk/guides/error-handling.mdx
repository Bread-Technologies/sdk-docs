---
title: "Error Handling"
description: "Handle errors gracefully in the Bread SDK"
---

## Overview

The Bread SDK provides a comprehensive error hierarchy for handling different failure scenarios. All errors inherit from `bread.APIError`.

## Error Hierarchy

All Bread SDK errors inherit from `BreadError`:

<AccordionGroup>
  <Accordion title="APIConnectionError - Network Issues" icon="wifi-slash">
    Connection failures, timeouts, network errors.
    
    **Subclasses:**
    - `APITimeoutError` - Request exceeded timeout threshold
    
    **Common causes:** Network connectivity, firewall, VPN issues
  </Accordion>
  
  <Accordion title="APIStatusError - HTTP Status Errors" icon="triangle-exclamation">
    HTTP error responses from the API (4xx, 5xx status codes).
    
    **Subclasses:**
    - `BadRequestError` (400) - Invalid request parameters
    - `AuthenticationError` (401) - Invalid or missing API key
    - `PermissionDeniedError` (403) - Insufficient permissions
    - `NotFoundError` (404) - Resource doesn't exist
    - `ConflictError` (409) - Resource conflict (e.g., immutable field change)
    - `UnprocessableEntityError` (422) - Validation error
    - `RateLimitError` (429) - Too many requests
    - `InternalServerError` (≥500) - Server-side error
  </Accordion>
  
  <Accordion title="APIResponseValidationError - Invalid Response" icon="circle-xmark">
    API returned data that doesn't match expected schema.
    
    **Common causes:** API version mismatch, malformed response
  </Accordion>
</AccordionGroup>

## Error Status Codes

<CardGroup cols={2}>
  <Card title="400 - BadRequestError" icon="circle-exclamation">
    Malformed request
  </Card>
  <Card title="401 - AuthenticationError" icon="lock">
    Invalid API key
  </Card>
  <Card title="403 - PermissionDeniedError" icon="ban">
    Insufficient permissions
  </Card>
  <Card title="404 - NotFoundError" icon="magnifying-glass">
    Resource not found
  </Card>
  <Card title="409 - ConflictError" icon="triangle-exclamation">
    Resource conflict (e.g., immutable field change)
  </Card>
  <Card title="422 - UnprocessableEntityError" icon="circle-xmark">
    Invalid entity
  </Card>
  <Card title="429 - RateLimitError" icon="gauge-high">
    Rate limit exceeded
  </Card>
  <Card title="500+ - InternalServerError" icon="server">
    Server error
  </Card>
</CardGroup>

## Basic Error Handling

<CodeGroup>

```python Python
import aibread
from aibread import Bread

client = Bread()

try:
    repos = client.repo.list()
except aibread.APIConnectionError as e:
    print("Server could not be reached")
    print(e.__cause__)  # Underlying exception
except aibread.RateLimitError as e:
    print("Rate limited - back off")
except aibread.AuthenticationError as e:
    print("Invalid API key")
except aibread.APIStatusError as e:
    print(f"Status: {e.status_code}")
    print(f"Response: {e.response}")
```

```typescript TypeScript
import Bread, { APIConnectionError, RateLimitError, AuthenticationError, APIStatusError } from '@aibread/sdk';

const client = new Bread();

try {
  const repos = await client.repo.list();
} catch (error) {
  if (error instanceof APIConnectionError) {
    console.log('Server could not be reached');
    console.log(error.cause);  // Underlying exception
  } else if (error instanceof RateLimitError) {
    console.log('Rate limited - back off');
  } else if (error instanceof AuthenticationError) {
    console.log('Invalid API key');
  } else if (error instanceof APIStatusError) {
    console.log(`Status: ${error.statusCode}`);
    console.log(`Response: ${error.response}`);
  }
}
```

</CodeGroup>

## Specific Error Handling

### Authentication Errors

<CodeGroup>

```python Python
import aibread
from aibread import Bread

try:
    client = Bread()
    repos = client.repo.list()
except aibread.AuthenticationError:
    print("Invalid API key - check BREAD_API_KEY environment variable")
except aibread.PermissionDeniedError:
    print("Valid key but insufficient permissions")
```

```typescript TypeScript
import Bread, { AuthenticationError, PermissionDeniedError } from '@aibread/sdk';

try {
  const client = new Bread();
  const repos = await client.repo.list();
} catch (error) {
  if (error instanceof AuthenticationError) {
    console.log('Invalid API key - check BREAD_API_KEY environment variable');
  } else if (error instanceof PermissionDeniedError) {
    console.log('Valid key but insufficient permissions');
  }
}
```

</CodeGroup>

### Not Found Errors

<CodeGroup>

```python Python
import aibread
from aibread import Bread

client = Bread()

try:
    repo = client.repo.get("my_repo")
except aibread.NotFoundError:
    # Create if doesn't exist
    repo = client.repo.set(repo_name="my_repo")
    print("Repository created")
```

```typescript TypeScript
import Bread, { NotFoundError } from '@aibread/sdk';

const client = new Bread();

try {
  const repo = await client.repo.get('my_repo');
} catch (error) {
  if (error instanceof NotFoundError) {
    // Create if doesn't exist
    const repo = await client.repo.create({ repo_name: 'my_repo' });
    console.log('Repository created');
  }
}
```

</CodeGroup>

### Conflict Errors

<CodeGroup>

```python Python
import aibread
from aibread import Bread

client = Bread()

try:
    repo = client.repo.set(
        repo_name="existing_repo",
        base_model="different_model"
    )
except aibread.ConflictError:
    print("Cannot change base_model of existing repository")
```

```typescript TypeScript
import Bread, { ConflictError } from '@aibread/sdk';

const client = new Bread();

try {
  const repo = await client.repo.create({
    repo_name: 'existing_repo',
    base_model: 'different_model',
  });
} catch (error) {
  if (error instanceof ConflictError) {
    console.log('Cannot change base_model of existing repository');
  }
}
```

</CodeGroup>

### Rate Limiting

<CodeGroup>

```python Python
import aibread
import time

def retry_with_backoff(fn, max_retries=3):
    """Retry function with exponential backoff"""
    for attempt in range(max_retries):
        try:
            return fn()
        except aibread.RateLimitError:
            if attempt == max_retries - 1:
                raise
            wait_time = 2 ** attempt
            print(f"Rate limited, waiting {wait_time}s")
            time.sleep(wait_time)

# Usage
repos = retry_with_backoff(lambda: client.repo.list())
```

```typescript TypeScript
import { RateLimitError } from '@aibread/sdk';

async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3
): Promise<T> {
  /** Retry function with exponential backoff */
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (error instanceof RateLimitError) {
        if (attempt === maxRetries - 1) {
          throw error;
        }
        const waitTime = Math.pow(2, attempt);
        console.log(`Rate limited, waiting ${waitTime}s`);
        await new Promise(resolve => setTimeout(resolve, waitTime * 1000));
      } else {
        throw error;
      }
    }
  }
  throw new Error('Max retries exceeded');
}

// Usage
const repos = await retryWithBackoff(() => client.repo.list());
```

</CodeGroup>

### Connection Errors

<CodeGroup>

```python Python
import aibread
import time

def retry_on_connection_error(fn, max_retries=3):
    """Retry on connection failures"""
    for attempt in range(max_retries):
        try:
            return fn()
        except aibread.APIConnectionError as e:
            if attempt == max_retries - 1:
                print(f"Failed after {max_retries} attempts")
                raise
            print(f"Connection error, retry {attempt + 1}/{max_retries}")
            time.sleep(2)
        except aibread.APITimeoutError as e:
            if attempt == max_retries - 1:
                raise
            print(f"Timeout, retry {attempt + 1}/{max_retries}")
            time.sleep(2)

# Usage
repos = retry_on_connection_error(lambda: client.repo.list())
```

```typescript TypeScript
import { APIConnectionError, APITimeoutError } from '@aibread/sdk';

async function retryOnConnectionError<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3
): Promise<T> {
  /** Retry on connection failures */
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (error instanceof APIConnectionError) {
        if (attempt === maxRetries - 1) {
          console.log(`Failed after ${maxRetries} attempts`);
          throw error;
        }
        console.log(`Connection error, retry ${attempt + 1}/${maxRetries}`);
        await new Promise(resolve => setTimeout(resolve, 2000));
      } else if (error instanceof APITimeoutError) {
        if (attempt === maxRetries - 1) {
          throw error;
        }
        console.log(`Timeout, retry ${attempt + 1}/${maxRetries}`);
        await new Promise(resolve => setTimeout(resolve, 2000));
      } else {
        throw error;
      }
    }
  }
  throw new Error('Max retries exceeded');
}

// Usage
const repos = await retryOnConnectionError(() => client.repo.list());
```

</CodeGroup>

## Error Properties

All `APIError` subclasses have:
- `message`: Error message
- `request`: Original request object
- `body`: Response body (if available)

`APIStatusError` additionally has:
- `response`: Full response object
- `statusCode`: HTTP status code

<CodeGroup>

```python Python
import aibread

try:
    client.repo.get("nonexistent")
except aibread.APIStatusError as e:
    print(f"Status code: {e.status_code}")
    print(f"Response headers: {e.response.headers}")
    print(f"Response body: {e.body}")
    print(f"Request URL: {e.request.url}")
```

```typescript TypeScript
import { APIStatusError } from '@aibread/sdk';

try {
  await client.repo.get('nonexistent');
} catch (error) {
  if (error instanceof APIStatusError) {
    console.log(`Status code: ${error.statusCode}`);
    console.log(`Response headers:`, error.response?.headers);
    console.log(`Response body:`, error.body);
    console.log(`Request URL:`, error.request?.url);
  }
}
```

</CodeGroup>

## Comprehensive Error Handler

<CodeGroup>

```python Python
import aibread
import logging
import time

logger = logging.getLogger(__name__)

def handle_bread_error(e: Exception) -> dict:
    """Central error handler for Bread SDK"""
    if isinstance(e, aibread.AuthenticationError):
        logger.error("Authentication failed")
        return {"error": "auth_failed", "retry": False}
    
    elif isinstance(e, aibread.PermissionDeniedError):
        logger.error("Permission denied")
        return {"error": "permission_denied", "retry": False}
    
    elif isinstance(e, aibread.NotFoundError):
        logger.warning("Resource not found")
        return {"error": "not_found", "retry": False}
    
    elif isinstance(e, aibread.ConflictError):
        logger.warning("Resource conflict")
        return {"error": "conflict", "retry": False}
    
    elif isinstance(e, aibread.RateLimitError):
        logger.warning("Rate limited")
        return {"error": "rate_limited", "retry": True, "wait": 60}
    
    elif isinstance(e, aibread.APITimeoutError):
        logger.error("Request timeout")
        return {"error": "timeout", "retry": True}
    
    elif isinstance(e, aibread.APIConnectionError):
        logger.error("Connection failed")
        return {"error": "connection_failed", "retry": True}
    
    elif isinstance(e, aibread.InternalServerError):
        logger.error("Server error")
        return {"error": "server_error", "retry": True}
    
    elif isinstance(e, aibread.APIStatusError):
        logger.error(f"API error: {e.status_code}")
        return {"error": "api_error", "status": e.status_code, "retry": e.status_code >= 500}
    
    else:
        logger.error(f"Unexpected error: {e}")
        return {"error": "unknown", "retry": False}

# Usage
try:
    result = client.repo.list()
except Exception as e:
    error_info = handle_bread_error(e)
    
    if error_info["retry"]:
        # Retry logic
        time.sleep(error_info.get("wait", 5))
        result = client.repo.list()
    else:
        # Handle non-retryable error
        raise
```

```typescript TypeScript
import {
  AuthenticationError,
  PermissionDeniedError,
  NotFoundError,
  ConflictError,
  RateLimitError,
  APITimeoutError,
  APIConnectionError,
  InternalServerError,
  APIStatusError,
} from '@aibread/sdk';

interface ErrorInfo {
  error: string;
  retry: boolean;
  wait?: number;
  status?: number;
}

function handleBreadError(e: unknown): ErrorInfo {
  /** Central error handler for Bread SDK */
  if (e instanceof AuthenticationError) {
    console.error('Authentication failed');
    return { error: 'auth_failed', retry: false };
  }
  
  if (e instanceof PermissionDeniedError) {
    console.error('Permission denied');
    return { error: 'permission_denied', retry: false };
  }
  
  if (e instanceof NotFoundError) {
    console.warn('Resource not found');
    return { error: 'not_found', retry: false };
  }
  
  if (e instanceof ConflictError) {
    console.warn('Resource conflict');
    return { error: 'conflict', retry: false };
  }
  
  if (e instanceof RateLimitError) {
    console.warn('Rate limited');
    return { error: 'rate_limited', retry: true, wait: 60 };
  }
  
  if (e instanceof APITimeoutError) {
    console.error('Request timeout');
    return { error: 'timeout', retry: true };
  }
  
  if (e instanceof APIConnectionError) {
    console.error('Connection failed');
    return { error: 'connection_failed', retry: true };
  }
  
  if (e instanceof InternalServerError) {
    console.error('Server error');
    return { error: 'server_error', retry: true };
  }
  
  if (e instanceof APIStatusError) {
    console.error(`API error: ${e.statusCode}`);
    return { error: 'api_error', status: e.statusCode, retry: e.statusCode >= 500 };
  }
  
  console.error(`Unexpected error: ${e}`);
  return { error: 'unknown', retry: false };
}

// Usage
try {
  const result = await client.repo.list();
} catch (error) {
  const errorInfo = handleBreadError(error);
  
  if (errorInfo.retry) {
    // Retry logic
    await new Promise(resolve => setTimeout(resolve, (errorInfo.wait || 5) * 1000));
    const result = await client.repo.list();
  } else {
    // Handle non-retryable error
    throw error;
  }
}
```

</CodeGroup>

## Retry Configuration

The SDK automatically retries certain errors:

<CodeGroup>

```python Python
from aibread import Bread

# Default: 2 retries
client = Bread()

# Disable retries
client = Bread(max_retries=0)

# Custom retry count
client = Bread(max_retries=5)

# Per-request override
client.with_options(max_retries=3).repo.list()
```

```typescript TypeScript
import Bread from '@aibread/sdk';

// Default: 2 retries
const client = new Bread();

// Disable retries
const clientNoRetries = new Bread({ maxRetries: 0 });

// Custom retry count
const clientCustomRetries = new Bread({ maxRetries: 5 });

// Per-request override (if SDK supports it)
await client.repo.list({ maxRetries: 3 });
```

</CodeGroup>

**Auto-retried conditions**:
- 408 Request Timeout
- 409 Conflict
- 429 Rate Limit
- ≥500 Internal Server Errors
- Connection errors

## Timeout Configuration

Configure timeouts to prevent hanging:

<CodeGroup>

```python Python
import httpx
from aibread import Bread

# Global timeout (20 seconds)
client = Bread(timeout=20.0)

# Granular timeout control
client = Bread(
    timeout=httpx.Timeout(
        60.0,         # Total
        connect=2.0,  # Connection
        read=5.0,     # Read
        write=10.0    # Write
    )
)

# Per-request override
try:
    result = client.with_options(timeout=5.0).repo.list()
except aibread.APITimeoutError:
    print("Request timed out after 5 seconds")
```

```typescript TypeScript
import Bread, { APITimeoutError } from '@aibread/sdk';

// Global timeout (20 seconds)
const client = new Bread({ timeout: 20000 });

// Granular timeout control (if SDK supports it)
const clientGranular = new Bread({
  timeout: {
    total: 60000,    // Total
    connect: 2000,   // Connection
    read: 5000,      // Read
    write: 10000,    // Write
  },
});

// Per-request override
try {
  const result = await client.repo.list({ timeout: 5000 });
} catch (error) {
  if (error instanceof APITimeoutError) {
    console.log('Request timed out after 5 seconds');
  }
}
```

</CodeGroup>

## Async Error Handling

Error handling works the same with async client:

<CodeGroup>

```python Python
import asyncio
import aibread
from aibread import AsyncBread

async def safe_api_call():
    try:
        async with AsyncBread() as client:
            repos = await client.repo.list()
            return repos
    except aibread.APIConnectionError:
        print("Connection failed")
    except aibread.AuthenticationError:
        print("Auth failed")
    except aibread.APIStatusError as e:
        print(f"API error: {e.status_code}")

asyncio.run(safe_api_call())
```

```typescript TypeScript
import Bread, {
  APIConnectionError,
  AuthenticationError,
  APIStatusError,
} from '@aibread/sdk';

async function safeApiCall() {
  try {
    const client = new Bread();
    const repos = await client.repo.list();
    return repos;
  } catch (error) {
    if (error instanceof APIConnectionError) {
      console.log('Connection failed');
    } else if (error instanceof AuthenticationError) {
      console.log('Auth failed');
    } else if (error instanceof APIStatusError) {
      console.log(`API error: ${error.statusCode}`);
    }
  }
}

await safeApiCall();
```

</CodeGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Catch Specific Errors First" icon="filter">
    Handle specific error types before catching generic `APIError`
  </Accordion>

  <Accordion title="Implement Retry Logic" icon="rotate">
    Retry on transient errors (rate limits, timeouts, server errors)
  </Accordion>

  <Accordion title="Log Error Details" icon="file-lines">
    Log status codes, request details, and error messages for debugging
  </Accordion>

  <Accordion title="Don't Retry Auth Errors" icon="lock">
    Authentication and permission errors are not transient - fix the root cause
  </Accordion>

  <Accordion title="Use Circuit Breakers" icon="toggle-off">
    For production, implement circuit breakers to prevent cascading failures
  </Accordion>

  <Accordion title="Set Appropriate Timeouts" icon="clock">
    Configure timeouts based on your use case (quick requests vs. long-running jobs)
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Production Patterns"
    icon="shield"
    href="/sdk/guides/production-patterns"
  >
    Production-ready workflow examples
  </Card>
  <Card
    title="Advanced Features"
    icon="wand-magic-sparkles"
    href="/sdk/guides/advanced-features"
  >
    Advanced SDK capabilities
  </Card>
</CardGroup>

